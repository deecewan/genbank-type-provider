
@misc{community_for_f_michael_2016,
	title = {Michael {Newton} - {Type} {Providers} from the {Ground} {Up}},
	url = {https://www.youtube.com/watch?v=pXT0li6zxKQ},
	urldate = {2018-03-22},
	author = {{Community for F\#}},
	month = feb,
	year = {2016},
	keywords = {\#hangoutsonair, \#hoa, Hangouts On Air}
}

@misc{dev_day_tomas_2015,
	title = {Tomas {Petricek} - {Understanding} the {World} with {Type} {Providers}},
	url = {https://www.youtube.com/watch?v=LCiPehPzNow},
	urldate = {2018-03-22},
	author = {{Dev Day}},
	month = sep,
	year = {2015},
	keywords = {DevDay, DevDay 2015, F\# (Programming Language), Tomas Petricek, Type Providers}
}

@article{wright_syntactic_1994,
	title = {A {Syntactic} {Approach} to {Type} {Soundness}},
	volume = {115},
	issn = {08905401},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0890540184710935},
	doi = {10.1006/inco.1994.1093},
	abstract = {We present a new approach to proving type soundness for Hindley/Milner-style polymorphic type systems. The keys to our approach are (1) an adaptation of subject reduction theorems from combinatory logic to programming languages, and (2) the use of rewriting techniques for the speci cation of the language semantics. The approach easily extends from polymorphic functional languages to imperative languages that provide references, exceptions, continuations, and similar features. We illustrate the technique with a type soundness theorem for the core of Standard ML, which includes the rst type soundness proof for polymorphic exceptions and continuations.},
	language = {en},
	number = {1},
	urldate = {2018-03-22},
	journal = {Information and Computation},
	author = {Wright, A.K. and Felleisen, M.},
	month = nov,
	year = {1994},
	pages = {38--94},
	file = {Wright and Felleisen - 1994 - A Syntactic Approach to Type Soundness.pdf:/Users/david/Zotero/storage/JHMPGTBP/Wright and Felleisen - 1994 - A Syntactic Approach to Type Soundness.pdf:application/pdf}
}

@article{lee_bioinformatics_2012,
	title = {Bioinformatics tools and databases for analysis of next-generation sequence data},
	volume = {11},
	issn = {2041-2649, 2041-2657},
	url = {https://academic.oup.com/bfg/article-lookup/doi/10.1093/bfgp/elr037},
	doi = {10.1093/bfgp/elr037},
	abstract = {Genome sequencing has been revolutionized by next-generation technologies, which can rapidly produce vast quantities of data at relatively low cost. With data production now no longer being limited, there is a huge challenge to analyse the data flood and interpret biological meaning. Bioinformatics scientists have risen to the challenge and a large number of software tools and databases have been produced and these continue to evolve with this rapidly advancing field. Here, we outline some of the tools and databases commonly used for the analysis of next-generation sequence data with comment on their utility.},
	language = {en},
	number = {1},
	urldate = {2018-03-22},
	journal = {Briefings in Functional Genomics},
	author = {Lee, H. C. and Lai, K. and Lorenc, M. T. and Imelfort, M. and Duran, C. and Edwards, D.},
	month = jan,
	year = {2012},
	pages = {12--24},
	annote = {Talks about the large amount of data + the software being built to help people analyze the data better},
	file = {Lee et al. - 2012 - Bioinformatics tools and databases for analysis of.pdf:/Users/david/Zotero/storage/FGWNXJKI/Lee et al. - 2012 - Bioinformatics tools and databases for analysis of.pdf:application/pdf}
}

@article{syme_extensible_2007,
	title = {Extensible pattern matching via a lightweight language extension},
	volume = {42},
	issn = {03621340},
	url = {http://portal.acm.org/citation.cfm?doid=1291220.1291159},
	doi = {10.1145/1291220.1291159},
	abstract = {Pattern matching of algebraic data types (ADTs) is a standard feature in typed functional programming languages, but it is well known that it interacts poorly with abstraction. While several partial solutions to this problem have been proposed, few have been implemented or used. This paper describes an extension to the .NET language F\# called active patterns, which supports pattern matching over abstract representations of generic heterogeneous data such as XML and term structures, including where these are represented via object models in other .NET languages. Our design is the ﬁrst to incorporate both ad hoc pattern matching functions for partial decompositions and “views” for total decompositions, and yet remains a simple and lightweight extension. We give a description of the language extension along with numerous motivating examples. Finally we describe how this feature would interact with other reasonable and related language extensions: existential types quantiﬁed at data discrimination tags, GADTs, and monadic generalizations of pattern matching.},
	language = {en},
	number = {9},
	urldate = {2018-03-22},
	journal = {ACM SIGPLAN Notices},
	author = {Syme, Don and Neverov, Gregory and Margetson, James},
	month = oct,
	year = {2007},
	pages = {29},
	annote = {Earlier work before type providers on compiler extensions to make it easier to interact with data},
	file = {Syme et al. - 2007 - Extensible pattern matching via a lightweight lang.pdf:/Users/david/Zotero/storage/A3BT4VN8/Syme et al. - 2007 - Extensible pattern matching via a lightweight lang.pdf:application/pdf}
}

@patent{meijer_type_2011,
	title = {Type inference for object-oriented languages},
	url = {https://patents.google.com/patent/US7873592/en},
	abstract = {Systems and methods facilitate type inference in a computer-programming environment. Type inference can be applied to generic method or function invocation in object-oriented languages to determine a type argument list left implicit by a programmer. One or more type arguments can be identified as a parameter type to which all other types in a set of associated parameter types can be converted.},
	nationality = {US},
	language = {en},
	assignee = {Microsoft Corp},
	number = {US7873592B2},
	urldate = {2018-03-22},
	author = {Meijer, Henricus Johannes Maria and Bierman, Gavin and Torgersen, Mads and Hejlsberg, Anders and Velzen, Danny van and Hallam, Peter A. and Lippert, Robert Eric and Warren, Matthew J. and Vick, Paul A. and Silver, Amanda},
	month = jan,
	year = {2011},
	keywords = {inference, method, system, type, types},
	annote = {Classifications
G06F9/4488:},
	annote = {Created by the same company that has created F\# and type providers},
	file = {Fulltext PDF:/Users/david/Zotero/storage/UZ5BV82Z/Meijer et al. - 2011 - Type inference for object-oriented languages.pdf:application/pdf}
}

@inproceedings{petricek_types_2016,
	title = {Types from data: making structured data first-class citizens in {F}\#},
	isbn = {978-1-4503-4261-2},
	shorttitle = {Types from data},
	url = {http://dl.acm.org/citation.cfm?doid=2908080.2908115},
	doi = {10.1145/2908080.2908115},
	abstract = {Most modern applications interact with external services and access data in structured formats such as XML, JSON and CSV. Static type systems do not understand such formats, often making data access more cumbersome. Should we give up and leave the messy world of external data to dynamic typing and runtime checks? Of course, not! We present F\# Data, a library that integrates external structured data into F\#. As most real-world data does not come with an explicit schema, we develop a shape inference algorithm that infers a shape from representative sample documents. We then integrate the inferred shape into the F\# type system using type providers. We formalize the process and prove a relative type soundness theorem.},
	language = {en},
	urldate = {2018-03-22},
	publisher = {ACM Press},
	author = {Petricek, Tomas and Guerra, Gustavo and Syme, Don},
	year = {2016},
	pages = {477--490},
	file = {Petricek et al. - 2016 - Types from data making structured data first-clas.pdf:/Users/david/Zotero/storage/PETVADUA/Petricek et al. - 2016 - Types from data making structured data first-clas.pdf:application/pdf}
}

@inproceedings{syme_world_2014,
	title = {A {World} of financial data at your fingertips, functional, strongly tooled and strongly typed},
	doi = {10.1109/CIFEr.2014.6924046},
	abstract = {Modern financial programming and modelling is highly information rich, but our programming tools are often information sparse, especially our strongly typed ones. This leads to an impasse where improvements in programming to aid accuracy and clarity of financial software implementation such as units-of-measure analysis or typed functional programming can't be rolled out to industry. The F\# programming language is increasingly used in implementing financial software and models [1]. It includes a feature called “Type Providers” to support the integration of large-scale information sources into a strongly typed functional-first programming environment. In this tutorial, we show that through the use of this simple, intuitive, scalable and on-demand mechanism called "type providers", we can bridge modern strongly-typed languages to the myriad of heterogeneous data services found in the modern financial programming context - for example entity graphs, databases, web services, spreadsheets and even other programming languages. We demonstrate applications using the F\# language and the Xenomorph TimeScape time-series database system.},
	booktitle = {2014 {IEEE} {Conference} on {Computational} {Intelligence} for {Financial} {Engineering} {Economics} ({CIFEr})},
	author = {Syme, D. and Battocchi, K. and Petricek, T.},
	month = mar,
	year = {2014},
	keywords = {Computer languages, databases, Databases, entity graphs, F\# programming language, financial data, financial data processing, financial modelling, financial programming, financial software implementation, functional programming, heterogeneous data services, Production, Programming, programming languages, programming tools, Protocols, Software, software tools, spreadsheets, strongly typed functional-first programming languages, Tutorials, type providers, typed functional programming, units-of-measure analysis, Web services, Xenomorph TimeScape time-series database system},
	pages = {xi--xi},
	file = {IEEE Xplore Abstract Record:/Users/david/Zotero/storage/KREVHYFZ/6924046.html:text/html;Syme et al. - 2014 - A World of financial data at your fingertips, func.pdf:/Users/david/Zotero/storage/4BJCNHCX/Syme et al. - 2014 - A World of financial data at your fingertips, func.pdf:application/pdf}
}

@incollection{hutchison_type_2006,
	address = {Berlin, Heidelberg},
	title = {Type {Inference} in {Systems} {Biology}},
	volume = {4210},
	isbn = {978-3-540-46166-1 978-3-540-46167-8},
	url = {http://link.springer.com/10.1007/11885191_4},
	abstract = {Type checking and type inference are important concepts and methods of programming languages and software engineering. Type checking is a way to ensure some level of consistency, depending on the type system, in large programs and in complex assemblies of software components. Type inference provides powerful static analyses of preexisting programs without types, and facilitates the use of type systems by freeing the user from entering type information. In this paper, we investigate the application of these concepts to systems biology. More speciﬁcally, we consider the Systems Biology Markup Language SBML and the Biochemical Abstract Machine BIOCHAM with their repositories of models of biochemical systems. We study three type systems: one for checking or inferring the functions of proteins in a reaction model, one for checking or inferring the activation and inhibition eﬀects of proteins in a reaction model, and another one for checking or inferring the topology of compartments or locations. We show that the framework of abstract interpretation elegantly applies to the formalization of these abstractions and to the implementation of linear time type checking as well as type inference algorithms. Through some examples, we show that the analysis of biochemical models by type inference provides accurate and useful information. Interestingly, such a mathematical formalization of the abstractions used in systems biology already provides some guidelines for the extensions of biochemical reaction rule languages.},
	urldate = {2018-03-22},
	booktitle = {Computational {Methods} in {Systems} {Biology}},
	publisher = {Springer Berlin Heidelberg},
	author = {Fages, François and Soliman, Sylvain},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Priami, Corrado},
	year = {2006},
	doi = {10.1007/11885191_4},
	pages = {48--62},
	file = {Fages and Soliman - 2006 - Type Inference in Systems Biology.pdf:/Users/david/Zotero/storage/KMMQZN8S/Fages and Soliman - 2006 - Type Inference in Systems Biology.pdf:application/pdf}
}

@misc{lesk_arthur_m._bioinformatics_2013,
	title = {Bioinformatics},
	url = {https://www.britannica.com/science/bioinformatics},
	abstract = {Bioinformatics: Bioinformatics, a hybrid science that links biological data with techniques for information storage, distribution, and analysis to support multiple areas of scientific research, including biomedicine. Bioinformatics is fed by high-throughput data-generating experiments, including genomic sequence},
	language = {en},
	urldate = {2018-04-16},
	journal = {Encyclopædia Britannica},
	publisher = {Encyclopædia Britannica, inc.},
	author = {Lesk, Arthur M.},
	month = jul,
	year = {2013},
	file = {Snapshot:/Users/david/Zotero/storage/P94B3MBB/bioinformatics.html:text/html}
}

@article{duggan_explaining_1996,
	title = {Explaining type inference},
	volume = {27},
	issn = {0167-6423},
	url = {http://www.sciencedirect.com/science/article/pii/0167642395000070},
	doi = {10.1016/0167-6423(95)00007-0},
	abstract = {Type inference is the compile-time process of reconstructing missing type information in a program based on the usage of its variables. ML and Haskell are two languages where this aspect of compilation has enjoyed some popularity, allowing type information to be omitted while static type checking is still performed. Type inference may be expected to have some application in the prototyping and scripting languages which are becoming increasingly popular. A difficulty with type inference is the confusing and sometimes counter-intuitive diagnostics produced by the type checker as a result of type errors. A modification of the unification algorithm used in Hindley-Milner type inference is presented, which allows the specific reasoning which led to a program variable having a particular type to be recorded for type explanation. This approach is close to the intuitive process used in practice for debugging type errors. The algorithm is practical, and has been implemented in the Standard ML of New Jersey compiler. The modified unification algorithm also appears useful in other domains, including logic program debuggers and semantics-based programming environments.},
	number = {1},
	urldate = {2018-04-16},
	journal = {Science of Computer Programming},
	author = {Duggan, Dominic and Bent, Frederick},
	month = jul,
	year = {1996},
	pages = {37--83},
	file = {ScienceDirect Full Text PDF:/Users/david/Zotero/storage/ZSHLWPAS/Duggan and Bent - 1996 - Explaining type inference.pdf:application/pdf;ScienceDirect Snapshot:/Users/david/Zotero/storage/FC9VUIA7/0167642395000070.html:text/html}
}

@techreport{cardelli_typeful_1989,
	title = {Typeful programming},
	abstract = {There exists an identifiable programming style based on the widespread use of type information handled through mechanical typechecking techniques. This typeful programming style is in a sense independent of the language it is embedded in; it adapts equally well to functional, imperative, object-oriented, and algebraic programming, and it is not incompatible with relational and concurrent programming. The main purpose of this paper is to show how typeful programming is best supported by sophisticated type systems, and how these systems can help in clarifying programming issues and in adding power and regularity to languages. We start with an introduction to the notions of types, subtypes and polymorphism. Then we introduce a general framework, derived in part from constructive logic, into which most of the known type systems can be accommodated and extended. The main part of the paper shows how this framework can be adapted systematically to cope with actual programming constructs. For concreteness we describe a particular programming language with advanced features; the emphasis here is on the combination of subtyping and polymorphism. We then discuss how typing concepts apply to large programs, made of collections of modules, and very large programs, made of collections of large programs. We also sketch how typing applies to system programming; an area which by nature escapes rigid typing. In summary, we compare the most common programming styles, suggesting that many of them are compatible with, and benefit from, a typeful discipline.},
	author = {Cardelli, Luca},
	year = {1989},
	file = {Citeseer - Full Text PDF:/Users/david/Zotero/storage/JCF5SDJK/Cardelli - 1989 - Typeful programming.pdf:application/pdf;Citeseer - Snapshot:/Users/david/Zotero/storage/724M924K/summary.html:text/html}
}

@misc{carter_type_2018,
	title = {Type {Providers}},
	url = {https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/},
	abstract = {Learn how an F\# type provider is a component that provides types, properties, and methods for use in your programs.},
	language = {en-us},
	urldate = {2018-04-16},
	journal = {.NET},
	author = {Carter, Philip and Wenzel, Maira and Latham, Luke},
	month = apr,
	year = {2018},
	file = {Snapshot:/Users/david/Zotero/storage/49IFNW9N/type-providers.html:text/html}
}